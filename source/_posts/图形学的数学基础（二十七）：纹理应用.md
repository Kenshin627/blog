---
title: 图形学的数学基础（二十七）：纹理应用
date: 2022-09-18 10:13:47
tags:
- Computer Graphic
- Math
mathjax: true
categories:
- Computer Graphic
- Math
- 计算机图形学的数学基础
---

# 图形学的数学基础（二十七）：纹理应用

在计算机图形学中，纹理贴图是使用图像、函数或其他数据源来改变物体表面外观的技术。例如，可以将一幅砖墙的彩色图像应用到一个多边形上，而不用对砖墙的几何形状进行确表示。通过这种方式将图像和物体表面结合起来，可以在建模、存储空间和速度方面节省很多资源。当然纹理不仅仅用于改变物体表面漫反射颜色,**纹理本质上是一个数据集**,可以用来存储任何我们需要的顶点数据,因此在方方面面得到了广泛的应用.本文将介绍MaterialMap、AlphaMap、BumpMap、NormalMap、ReliefMap、DisplacementMap、ParallaxMap、TexturedLight、ShadowMap、EnvironmentMap。
我们将以上纹理贴图的应用划分为6个大类：

- 控制着色信息
- 控制片元透明度
- 改变顶点法线
- 改变表面结构
- 阴影贴图
- 环境贴图
  
## 控制着色信息
根据$Blinn-phong\;Model$可知，物体表面着色信息有以下因子来控制：

![blinn-phong](图形学的数学基础（二十五）：着色/15.png)

$L = L_a+L_d+L_s = K_aE_a + K_d\dfrac{E}{r^2}max(0, \hat{n}\cdot\hat{l}) + K_s\dfrac{E}{r^2}max(0, \hat{n}\cdot\hat{h})^p$

|符号|解释|
| ------ | ------ |
|$K_a$|物体表面环境光吸收率|
|$E_a$|环境光强度|
|$\dfrac{E}{r^2}$|到达物体表面的光线|
|$K_d$|漫反射系数|
|$\hat{n}$|着色点法线|
|$\hat{l}$|光线单位矢量|
|$K_s$|高光系数|
|$p$|高光衰减因子|

可以看到有许多可以调节的参数来控制着色点的着色表现。虽然可以赋予顶点更多的属性来改变这些参数，但是要做到亚三角形的细节，就需要使用各种纹理，**对每个片元的着色参数进行调节**，这些纹理映射方法统称为材质映射（$Material\;Map$）。

最简单的就是漫反射映射，将纹理采样得到的值直接用于$K_d$项，很直观也很简单，这里不做过多赘述。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/2.png)


此外还可以改变镜面反射系数，如粗糙度（决定高光衰减）和高管反射系数。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/1.jpg)

## 控制片元透明度
纹理都是矩形的，但当我们要实现各种贴画（$decal$）或者镂空（$cutout$）效果时，往往不想让纹理贴满整个表面，也就是说一些地方的透明度为0，这时候$alphaMap$就登场了。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/3.png)

所以不需要把片元当作半透明进行混合，而是进行透明度测试 (Alpha Test)，将透明度小于阈值的 texel 认为是完全透明，直接抛弃片元，否则为完全不透明，测试完成后，再用 z-buffer 算法进行对所有完全不透明片元进行混合。透明度测试的伪代码如下：

```
if(texture.a < alphaThreshold)  discard
```

但是透明度测试在使用$mipmap$时会存在问题：如下图，第0级纹理连续四个texel的透明度为 [0.0, 1.0, 1.0, 0.0]，第1级纹理就为 [0.5, 0.5]，假设我们设定alphaThreshold为0.75，可知第0级纹理有1.5/4通过测试，但是在第一级纹理中，所有的纹素的值都变成了0.5， 0.5 < 0.75所以，所有像素都被抛弃。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/4.png)

于是在不同的$mipmap$纹理等级中，经过透明度测试留下来的像素占比也不一样，因为高等级纹理是对低等级纹理的范围平均，因此随着levelD的增大，纹素值会趋于平均化，之前在阈值之上的值，被平均化以后很有可能到阈值线之下，因此被抛弃的像素就越来越多：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/5.jpg)

我们来看一个例子，如下图所示，当相机距离树较近时，看起来一切正常：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/6.png)

当相机拉远后，树叶消失了一部分（由于mimmap均值化后，导致被抛弃像素占比增加）：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/7.png)

当相机拉远到相当一段距离后，发现树叶消失的更多：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/8.png)

一般解决办法有两个：
1. 手动调节每级mipmap透明度，或者在shader中根据纹理等级d对透明度缩放
2. 限制d的最大值

但这两种方法都只能是近似，不能很好解决问题，出现这个 问题的关键在于：不同 $mipmap$，用同样的透明度阈值会得到不同的 Coverage(代表测试留存的像素比例)

Castano提出了一种：保证coverage一致的情况下，自适应确定透明度阈值，并对原透明度缩放调整的方法。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/9.png)

经过这种特殊处理后，我们发现远处的树木表现恢复正常了。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/10.png)

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/11.png)

另外在对RGBA值进行线性插值时，要注意把alpha分量预乘到RGB分量，再进行插值：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/12.png)

比较实际的情况是：希望插值的结果偏向于不透明那边颜色的色调，所以通常而言，预乘后插值会比较合理。


## 凹凸贴图（$BumpMapping$）

用于改变表面片元法线的技术统称为凹凸贴图($BumpMapping$),凹凸贴图把各像素法线相关的信息存于一张Texture中，各像素的的法线通过这张纹理采样得到，使用采样得到的法线代替片元自身的法线进行着色光照计算，会看到凹凸不平的效果，是一种欺骗眼睛的效果。凹凸贴图思想最早由图形学大牛Jim Blinn提出，后来的Normal Mapping，Parrallax Mapping，Parallax Occulision Mapping，Relief Mapping，均是基于同样的思想，只是考虑的越来越全面，效果越来越逼真。

### 存储法线的几种方式

#### $heightMap$

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/13.jpg)


$heightMap$存储的是表面的相对高度，该高度的变化实际上表现了物体表面凹凸不平的特质，但是高度值不能直接用来计算光照，必须先将其转换为法线，再通过法线计算光照，这就是$heightMap$的核心原理。但是有个问题是，我们如何通过高度值计算出法线呢?

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/14.jpg)

要计算P点的法线，可以先求p点的切线，而切线正是函数曲线在p点的导数。

先拿二维的情况举例，点p的原始法线为$(0, 1)$，假设$h$为高度函数，根据差分近似求出点p的导数为：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/15.jpg)

$dp = c * (h(p + 1) - h(p))$

点p的切线矢量为：

$tangent(p) = (1, dp) = (1, c * (h(p + 1) - h(p)))$

将切线逆时针旋转90°，得到p点扰动后的法线。

$normal(p) = \begin{bmatrix}
    0&-1\\
    1&0
\end{bmatrix}tangent(p) = \begin{bmatrix}
    0&-1\\
    1&0
\end{bmatrix}\begin{bmatrix}
1\\
dp
\end{bmatrix} = \begin{bmatrix}
    -dp\\
    1
\end{bmatrix} = \begin{bmatrix}
    -(c∗(h(p+1)−h(p)))\\
    1
\end{bmatrix}$

注：上述推导中$c$为常数，表示法线被扰动影响大小的因子。

将上述推导到三维过程，只需要计算uv两个方向的梯度，剩下的和二维一致，计算切线，逆时针旋转90°计算法线。

- 原始法线$n(p) = (0,0,1)$
- 分别计算nv两个方向上的梯度：
    - $\dfrac{dp}{du} = c_1 *(h(u + 1)- h(u))$
    - $\dfrac{dp}{dv} = c_2 * (h(v + 1)- h(v))$
- 被扰动后的法线： $normal(p) = \begin{bmatrix}
    \dfrac{-d_p}{d_u}\\
    \dfrac{-d_p}{d_v}\\
    1
\end{bmatrix}.normalized()$

**注：所有计算出的法线都是在切线空间下的，需要乘以$TBN$矩阵转换到世界空间！**

#### $BumpMapping$
原始的凹凸贴图技术，由jim Blinn提出，后续的凹凸贴图技术都是基于其思想改进的。想法很简单，纹理贴图上每个像素点存储两个信息，一个是$u$方向的偏移矢量，一个是$v$方向上的偏移矢量。这样原始法线加上这两个矢量后自然得到了扰动后的法线。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/16.jpg)

#### $NormalMap$

我们知道Texture上可以存储三维的颜色作为漫反射系数，自然也可以存储法线向量的信息，利用$(u,v)$坐标查询每个点的法线向量，而不是用原始模型的法线信息，这就是$normalMap$。

明白了Normal Maps的原理之后，有一点重要的是，如何在存储这些法线信息呢？一种可选方案是存储对象空间下法线信息，这样在做完纹理查询后乘以世界空间矩阵直接就可以用了，但是不好的一点是，当对象空间发生变化时，那么该法线向量就不再正确了。更通用的做法是存储切线空间下的法线向量。

对象空间和切线空间法线贴图对比：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/17.jpg)

显然切线空间的存储方式更加灵活，不受制于种种限制，但是要付出的相应代价就是需要比较复杂的空间转换过程。

应用法线贴图后的渲染结果。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/18.jpg)

##### TBN空间

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/20.jpg)

切线空间定义于每一个顶点之中，是由切线（$Tangent$），副切线（$BiTangent$），顶点法线（$Normal$）以模型顶点为中心的坐标空间。$normalMap$中的法向量在切空间中表示，其中法向量总是大致指向正z方向。切线空间是一个三角形表面的局部空间:法线相对于单个三角形的局部参考系。把它想象成法向量的局部空间;它们都是指向正z方向的不管最终变换的方向是什么。使用一个特定的矩阵，我们可以将这个局部切线空间的法向量转换为世界或视图坐标，并将它们沿最终映射曲面的方向定向。这个矩阵就是$TBN$矩阵。接下来将详细推导$TBN$矩阵。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/22.jpg)

只需要下面两个步骤即可得到规范化的$TBN$矩阵。

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/21.jpg)

$E_1 = \triangle{U_1}T + \triangle{V_1}B$

$E_2 = \triangle{U_2}T + \triangle{V_2}B$

该公式的数学意义是，如何将一个点从uv空间映射到三维空间，其中TB作为基矢量，以uv空间中u和v的增长作为控制参数，假设三角形中存在一点p，则$\vec{AP} = u(p) * \vec{B} + v(p) * \vec{B}$,**点p可以表示为以TB为基矢量的uv空间，TB轴的线性组合。**

根据以上公式可以快速的推导出TB：

$\vec{T} = \dfrac{\triangle{V_1}E_2 - \triangle{V_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$

$\vec{B} = \dfrac{-\triangle{U_1}E_2 + \triangle{U_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$

目前给出的TB还是不是真正的切线与副切线，需要正交化后得到$TBN$矩阵:

$\vec{t}_⊥ = normalized(\vec{t} - (\vec{t}\cdot\vec{n})\vec{n})$

$\vec{b}_⊥ = normalized(\vec{b} - (\vec{b}\cdot\vec{n})\vec{n} - (\vec{b}\cdot\vec{t}_⊥)\vec{t}_⊥)$

其中n是建模软件中规定的顶点法线，可以看到n在正交化过程中不会受到影响，该过程是对TB向量进行方向的调整以及长度的归一化。TB在此过程后会相互垂直，此时将不再一定与UV方向保持相同。特别的，当调整顶点法线后，TB平面甚至将与三维空间中的三角形平面不同,也就是说归正交化后的$TBN$矩阵，$TB$轴将不再与$uv$相等，$uv$是正交化前的$TB$轴。

通过正交化后的$Tangent(T),Bitangent(B),Normal(N)$可以推导出$TBN$矩阵：

$TBN = \begin{bmatrix}
    T_x&B_x&N_x\\
    T_y&B_y&N_y\\
    T_z&B_z&N_z\\
\end{bmatrix}$

$normalMap$中存储的法线信息是基于$TBN$空间的，而光照计算需要所有的参数在同一空间下，以上计算出的$TBN$矩阵就是用于实现将物体（矢量）从其他空间到$TBN$空间的转换。

根据矩阵的逆的性质，$TBN$矩阵的逆矩阵可以用来将物体从$TBN$空间转换到原始空间，而$TBN$矩阵是正交化过的，因此它的逆等于转置。

$TBN^{-1} = TBN^T = \begin{bmatrix}
    T_x&T_y&T_z\\
    B_x&B_y&B_z\\
    N_x&N_y&N_z\\
\end{bmatrix}$

##### 利用法线贴图的信息计算模型光照
首先是纹理采样拿到当前像素点存储的值，如果纹理贴图是经过压缩的，需要计算（补全）三个通道值，然后将每个通道的数值范围从$[0,255]$映射到$[-1, 1]$。要做基于法线的光照计算，需要保证所有的参数（法线 光照方向 观测方向等）都在同一空间下。实现方式有两种，1：在vertexShader中将光照方向和观测方向从世界空间转换到$TBN$空间.2:在fragmentShader中将纹理采样得到的法线从$TBN$空间转换到世界空间。

对于第一种方法，需要每次都在片元着色器中对法线执行一次变换操作，而第二种方法只需要在顶点着色器做变换操作，性能









































一张图解释三种凹凸贴图的区别：

![漫反射贴图](图形学的数学基础（二十七）：纹理应用/19.png)